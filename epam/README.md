# What was discussed in an interview with EPAM. (september 2020)

![](epam_intro.png)

### Что нового появилось в Java 8?
<details><summary>Ответ</summary>

___

Из всех нововведений, появившихся в Java 8, нужно отметить самые важные:
стримы, лябмды и дефолтные/функциональные методы в интерфейсах. <br>
Будет большим плюсом, если к этому прибавить такие фичи, как :
* Ссылки на методы и конструкторы -> Integer::valueOf, System.out::print
* Функциональные интерфейсы -> Предикаты (Predicate), Функции (Function), Поставщики (Supplier), Потребители (Consumer)
* Опциональные значения (Optional)

*P.S. Если вы знаете, что есть некоторые фичи, но не можете их объяснить, лучше не упоминайте их в ответе.*
</details>


### Что такое функциональный интерфейс? Какие существует стандартные функциональные интерфейсы в Java?
<details><summary>Ответ</summary>

___

Функциональный интерфейс в Java – это интерфейс, который содержит только 1 абстрактный метод. <br>
Основное назначение – использование в лямбда выражениях и method reference. <br>

Стандартные функциональные интерфейсы, появившиеся в Java 8: <br>

* __Predicate<T>__ - проверяет соблюдение некоторого условия. **boolean test(T t);**
* __Consumer<T>__ - выполняет некоторое действие над объектом типа T, при этом ничего не возвращая. **void accept(T t);**
* __Function<T,R>__ - представляет функцию перехода от объекта типа T к объекту типа R. **R apply(T t);**
* __Supplier<T>__ - не принимает никаких аргументов, но должен возвращать объект типа T. **T get();**
* __UnaryOperator<T>__ - принимает в качестве параметра объект типа T, 
выполняет над ними операции и возвращает результат операций в виде объекта типа T. **T apply(T t);**
* __BinaryOperator<T>__ - принимает в качестве параметра два объекта типа T, 
выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа T. **T apply(T t1, T t2);**
</details>


### Можно ли объявить в функциональном интерфейсе метод с реализацией?
<details><summary>Ответ</summary>

___

Да, можно. Так как условием функционального интерфейса является наличие одного абстрактного метода, 
он вполне может иметь дефолтные и статические методы.
</details>


### Что такое стрим (Stream API)? Что стрим принимает в параметрах?
<details><summary>Ответ</summary>

___

Stream API — это новый способ работать со структурами данных в функциональном стиле.
Stream (поток) API (описание способов, которыми одна компьютерная программа может взаимодействовать с другой программой) 
— это по своей сути поток данных. Поток представляет последовательность элементов и предоставляет различные методы 
для произведения вычислений над данными элементами.
   
Большинство методов из Stream API принимают в качестве параметров лямбда-выражения, функциональные интерфейсы (описанные
ранее), описывающие конкретное поведение метода. Большая их часть должна одновременно быть невмешивающейся 
(non-interfering) и не запоминающей состояние (stateless).
</details>


### Какие виды операций над стримами вы знаете? Сможете их перечислить?
<details><summary>Ответ</summary>

___

Java Stream API предлагает два вида методов:
1. **Конвейерные** — возвращают другой stream, то есть работают как builder,
2. **Терминальные** — возвращают другой объект, такой как коллекция, примитивы, объекты, Optional и т.д.
<br>
Терминальные операции завершают работу над стримом, после них нельзя применять методы.

##### К конвеерным относятся:

| Метод stream | Описание | Пример  |
|--------------|:--------:|:--------|
| filter | Отфильтровывает записи, возвращает только записи, соответствующие условию |collection.stream().filter(«a1»::equals).count() |
| skip | Позволяет пропустить N первых элементов | collection.stream().skip(collection.size() — 1).findFirst().orElse(«1») |
| distinct | Возвращает стрим без дубликатов (для метода equals) | collection.stream().distinct().collect(Collectors.toList()) |
| map |	Преобразует каждый элемент стрима |	collection.stream().map((s) -> s + "_1").collect(Collectors.toList()) |
| peek | Возвращает тот же стрим, но применяет функцию к каждому элементу стрима | collection.stream().map(String::toUpperCase).peek((e) -> System.out.print("," + e)).collect(Collectors.toList()) |
| limit | Позволяет ограничить выборку определенным количеством первых элементов | collection.stream().limit(2).collect(Collectors.toList()) |
| sorted | Позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator | collection.stream().sorted().collect(Collectors.toList()) |
| mapToInt, mapToDouble, mapToLong | 	Аналог map, но возвращает числовой стрим (то есть стрим из числовых примитивов) | collection.stream().mapToInt((s) -> Integer.parseInt(s)).toArray() |
| flatMap, flatMapToInt, flatMapToDouble, flatMapToLong | Похоже на map, но может создавать из одного элемента несколько | collection.stream().flatMap((p) -> Arrays.asList(p.split(",")).stream()).toArray(String[]::new) |


##### К терминальным относятся: 

| Метод stream | Описание |	Пример |
|--------------|:--------:|:--------|
| findFirst | Возвращает первый элемент из стрима (возвращает Optional) | collection.stream().findFirst().orElse(«1»)
| findAny |	Возвращает любой подходящий элемент из стрима (возвращает Optional) | collection.stream().findAny().orElse(«1»)
| collect |	Представление результатов в виде коллекций и других структур данных | collection.stream().filter((s) -> s.contains(«1»)).collect(Collectors.toList())
| count | Возвращает количество элементов в стриме | collection.stream().filter(«a1»::equals).count()
| anyMatch | Возвращает true, если условие выполняется хотя бы для одного элемента | collection.stream().anyMatch(«a1»::equals)
| noneMatch | Возвращает true, если условие не выполняется ни для одного элемента |	collection.stream().noneMatch(«a8»::equals)
| allMatch | Возвращает true, если условие выполняется для всех элементов |	collection.stream().allMatch((s) -> s.contains(«1»))
| min |	Возвращает минимальный элемент, в качестве условия использует компаратор | collection.stream().min(String::compareTo).get()
| max |	Возвращает максимальный элемент, в качестве условия использует компаратор |	collection.stream().max(String::compareTo).get()
| forEach |	Применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется | set.stream().forEach((p) -> p.append("_1"));
| forEachOrdered |	Применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует | list.stream().forEachOrdered((p) -> p.append("_new"));
| toArray |	Возвращает массив значений стрима |	collection.stream().map(String::toUpperCase).toArray(String[]::new);
| reduce |	Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат |	collection.stream().reduce((s1, s2) -> s1 + s2).orElse(0)

</details>


### Какие есть способы создания стрима?
<details><summary>Ответ</summary>

___

    В разработке...
</details>



