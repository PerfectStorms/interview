# Задачи на алгоритмы, поставленные на собеседовании в Exactpro. (август 2020)

![](exactpro_intro.png)

Собеседование без теоретических вопросов, выглядит следующим образом:
Дано 3 задачи. За отведенное время (1 час) в реал тайме необходимо их решить. Решение должно быть оптимизированным и 
подходить по требованию поставленного условия.

Решение задачи должно быть сопровождено рассуждениями, так как нанимателю важно видеть аналитические способности и склад
ума собеседуемого.



### Search element
**Задача:**

Дан отсортированный массив. Необходимо написать метод, который проверяет, есть ли указанный элемент в массиве. Массив 
может быть очень большим. Тип данных – int. Массив одномерный.

<details><summary>Решение</summary>

___

Самое простое решение, это конечно же **линейный** перебор с помощью простого цикла
```java
public boolean linearSearch(int[] array, int number) {
    for(int i = 0; i < array.length; i++) {
        if (array[i] == number) {
            return true;
        }
    }
    return false;
}
```
, но данный метод очень плохо работает с большими массивами, так как в наихудшем случае (отсутствия элемента) придется
перебрать все элементы массива. Сложность такого алгоритма составляет **O(n)** - т.е. для массива с 1_000_000 элементов
потребуется 1_000_000 шагов.

Правильным подходом в этом случае является **бинарный поиск**, который как раз предназначен для отсортированных массивов.
```java
public boolean binarySearch(int[] array, int number){
    int low = 0;
    int high = array.length - 1;
    while(low <= high) {
        int mid = (low + high) / 2;
        if (array[mid] == number) return true;
        if (array[mid] > number) high = mid - 1;
        if (array[mid] < number) low = mid + 1;
    }   
    return false;
}
```
, где на каждой итерации происходит разделение массива на 2, вследствие чего ненужная половина (старшая или младшая)
просто отбрасывается, что позволяет нам оптимизировать алгоритм до сложности **O(log(n))** - т.е. для массива с 1_000_000
элементов - в наихудшем случае потребуется **20 шагов!**
</details>


### Cycle Buffer
**Задача:**

Реализуйте класс “Циклический Буфер”. Это коллекция с ограничением по размеру. Если при добавлении нового элемента в 
буфер оказывается, что он уже содержит максимальное количество элементов, самый старый элемент перезаписывается новым. 
Должны поддерживаться следующие операции:

- добавить элемент,
- получить текущее количество элементов,
- получить элемент по индексу,
- удалить элемент по индексу.

<details><summary>Решение</summary>

___

    В разработке...
</details>


### Singleton
**Задача:**

Написать класс TestClass. Создание объектов этого класса должно быть невозможно снаружи этого класса. Добавить 
статический метод getInstance(), создающий и возвращающий экземпляр класса TestClass. Если метод уже вызывался, он 
должен возвращать ранее созданный объект. Предусмотреть, что TestClass.getInstance() может быть вызван из нескольких 
потоков.

<details><summary>Решение</summary>

___

    В разработке...
</details>
